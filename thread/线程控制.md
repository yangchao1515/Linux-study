# 线程



### 线程知识要点

​		线程概念：

​		线程控制：线程创建    线程终止    线程等待    线程分离

​		线程安全：同步与互斥    互斥锁    条件变量    （生产者消费者模型） posix标准信号量    	 读写锁（读写者模型）

​		线程池：理解与基本实现

​		设计模式：线程安全的单例模式

​		多进程和多线程可以并行多任务







#### 	进程线程优缺点：

   		 一个进程中的线程共用一个虚拟地址空间

   		 线程间的通信更加方便

​    		线程的创建/销毁成本更低

​    		线程间切换调度成本更低

​    		线程的执行粒度更细

  		  线程之间缺乏访问控制---系统调用（exti），异常针对的是整个进程，健壮性低



​	 注意：==vfork创建一个子进程pcb共用一个同一个虚拟地址空间，怕出现调用栈混乱，因此子进程运行完毕或程序替换后父进程才开始运行==

==多线程pcb使用同一个虚拟地址空间：如何实现同时运行而不会出现调用栈混乱==

​    ==为每一个线程在虚拟地址空间中单独分配一块空间==







#### 每个线程都有自己独立的信息：

   		 栈

​    		寄存器

   		 error

  		 信号屏蔽字

​    		调度优先级



#### 线程之间共享的的数据：

​    		代码段，数据段

​    		文件描述表

​    		每种信号的处理方式

   		 用户id,组id，当前工作路径



#### 线程和进程的对比：

  		  同一个进程中线程是共用同一个进程虚拟地址空间的

​    		意味着创建/销毁线程的成本低，调度切换成本低，意味着线程间的通信非常方便

   		 线程是cpu调度的基本单位，进程资源分配的基本单位

​    		线程缺乏访问控制--系统调用/异常会对整个进程造成影响

​    		线程间通信非常方便---使用数据的收发需要更加注意代码的编写





### 线程控制：



#### 	1.线程创建：

操作系统并没有为用户提供直接创建线程的系统调用接口，因此大佬们就封装了一套线程库实现线程控制pthread.h  因为是库函数，因此编译链接是需要加上-pathread/-lpathread链接线程库



##### *==注意:*==

==（进程id）PID=TGID=主线程的id   用创建时用gitpid（）打印==

  (线程id)LWP=TID ：线程id    ps -L 查看=task_struct-pid

   ==使用pthread_self()获取pthread id =（线程创建时的tid）是一串很长的数字    tid线程地址空间首地址（pcb中的共享内存）==





#### 	2.线程终止：

    在线程入口函数中return；

    pthread_exit 退出调用线程

    线程退出也会成为僵尸线程（但是普通线程退出不出效果）

    线程地址空间无法被回收利用，造成内存泄漏

​    pthread_cancel    取消一个指定的线程



#### 	3.线程等待：

​     获取指定线程的返回值，允许系统回收资源,因为线程运行起来默认有一个属性;joinable;这个属性决定了线程退出后必须被等待，否则线程资源无法完全释放，成为僵尸线程（无直观体现）

处于joinable属性的线程退出后必须被等待，因为线程退出后，为了保存返回值，不会自动回收线程的资源（成为僵尸线程）

使用pthread_join接口实现线程等待，获取指定线程返回值，允许系统释放资源

​     线程等待的前提：线程能够被等待



#### 	4.线程分离:

将线程一个属性从joinable设置为detach属性,处于detach属性的线程，退出后资源直接自动被回收，这类线程不能被等待,分离自己也可以，对于一个线程来说，任意线程在任意位置调用都可以（pthread_detach)







